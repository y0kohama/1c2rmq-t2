
#Область ПрограммныйИнтерфейс

// Выполняет отправку сообщения в указанную точку обмена
// 
// Параметры:
// 	Сообщение - Произвольный - Отправляемое сообщение 
// 	ТочкаОбмена - СправочникСсылка.ИнтеграцияRMQТочкиОбмена - Точка обмена, в которую передается сообщение
// 	Параметры - Строка - Используется как routing key сообщения.					    
// 	Устойчивое - Булево - признак Persistent для сообщения (Ложь = 1, Истина = 2)  
//
Процедура ОтправитьСообщение(Сообщение, Знач ТочкаОбмена, Знач Параметры = Неопределено, Знач Устойчивое = Истина) Экспорт

	// Если проверки не будут пройдены, будет вызвано исключение
	ВыполнитьПроверкиПараметровОтправки(Сообщение, ТочкаОбмена, Параметры, Устойчивое);

	Если ТипЗнч(Параметры) = Тип("Строка") Тогда
		КлючМаршрута = СокрЛП(Параметры);
	Иначе
		КлючМаршрута = "";
	КонецЕсли;
	
	Попытка
		КлиентRMQ = НовыйКлиентRMQ(ТочкаОбмена.Владелец);
	Исключение
		
		ШаблонСообщения = НСтр("ru = 'Не удалось отправить сообщение в точку обмена %1.
							   |Отказ в подключении компоненты обмена с RabbitMQ:
							   |%2'", КодОсновногоЯзыка());
		
		ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонСообщения, 
			ТочкаОбмена, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
									   
		ВызватьИсключение ТекстОшибки;
		
	КонецПопытки;
	
	Попытка
		КлиентRMQ.BasicPublish(ТочкаОбмена.Имя, КлючМаршрута, Сообщение, 0, Устойчивое);
	Исключение

		ШаблонСообщения = НСтр("ru = 'Не удалось отправить сообщение в точку обмена %1 по причине:
							   |СВЕДЕНИЯ СИСТЕМЫ (если есть):
							   |%2
							   |СВЕДЕНИЯ КОМПОНЕНТЫ (если есть):
							   |%3'", КодОсновногоЯзыка());
				  
		ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонСообщения, 
			ТочкаОбмена, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			КлиентRMQ.GetLastError());

		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

		ВызватьИсключение ТекстОшибки;

	КонецПопытки;

КонецПроцедуры

#Область РезультатыОбработкиСообщений

Функция СтатусПодтвердить() Экспорт
	Возврат "ack";
КонецФункции

Функция СтатусОтклонить() Экспорт
	Возврат "nack";
КонецФункции

#КонецОбласти

#Область БезопасноеХранилище

// Записывает конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - СправочникСсылка.ИнтеграцияRMQОчереди - ссылка на объект информационной базы,//
//  Данные  - Произвольный - данные помещаемые в безопасное хранилище. Неопределенно - удаляет все данные.
//             Для удаления данных по ключу следует использовать процедуру УдалитьДанныеИзБезопасногоХранилища.
//  Ключ    - Строка       - ключ сохраняемых настроек, по умолчанию "Пароль".
//                           Ключ должен соответствовать правилам, установленным для идентификаторов:
//                           * Первым символом ключа должна быть буква или символ подчеркивания (_).
//                           * Каждый из последующих символов может быть буквой, цифрой или символом подчеркивания (_).
//
Процедура ЗаписатьДанныеВБезопасноеХранилище(Владелец, Данные,
		Ключ = "Пароль") Экспорт

	БезопасноеХранилищеДанных = РегистрыСведений.ИнтеграцияRMQБезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();

	Если Данные <> Неопределено Тогда

		Если БезопасноеХранилищеДанных.Выбран() Тогда

			ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
			Если ТипЗнч(ДанныеДляСохранения) <> Тип("Структура") Тогда
				ДанныеДляСохранения = Новый Структура();
			КонецЕсли;
			ДанныеДляСохранения.Вставить(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Записать();

		Иначе

			ДанныеДляСохранения = Новый Структура(Ключ, Данные);
			ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
			БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
			БезопасноеХранилищеДанных.Владелец = Владелец;
			БезопасноеХранилищеДанных.Записать();

		КонецЕсли;

	Иначе

		БезопасноеХранилищеДанных.Удалить();

	КонецЕсли;

КонецПроцедуры

// Возвращает данные из безопасного хранилища.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец    - СправочникСсылка.ИнтеграцияRMQОчереди - ссылка на объект информационной базы,
//                  представляющий объект-владелец сохраняемого пароля.
//  Ключи       - Строка - содержит список имен сохраненных данных, указанных через запятую.
// 
// Возвращаемое значение:
//  Произвольный, Структура, Неопределенно - данные из безопасного хранилища. Если указан один ключ,
//                            то возвращается его значение, иначе структура.
//                            Если данные отсутствуют - Неопределенно.
//
Функция ПрочитатьДанныеИзБезопасногоХранилища(Владелец,
		Ключи = "Пароль") Экспорт

	Результат = ДанныеИзБезопасногоХранилища(Владелец, Ключи);

	Если Результат <> Неопределено И Результат.Количество() = 1 Тогда
		Возврат ?(Результат.Свойство(Ключи), Результат[Ключи], Неопределено);
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Удаляет конфиденциальные данные в безопасное хранилище.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Безопасное хранилище недоступно для чтения пользователям (кроме администраторов),
// а доступно только коду, который делает обращения только к своей части данных и
// в том контексте, который предполагает чтение или запись конфиденциальных данных.
//
// Параметры:
//  Владелец - СправочникСсылка.ИнтеграцияRMQОчереди - ссылка на объект информационной базы,
//               представляющий объект-владелец сохраняемого пароля или строка до 128 символов.
//  Ключи    - Строка - содержит список имен удаляемых данных, указанных через запятую. 
//               Неопределено - удаляет все данные.
//
Процедура УдалитьДанныеИзБезопасногоХранилища(Владелец, Ключи = Неопределено) Экспорт

	БезопасноеХранилищеДанных = РегистрыСведений.ИнтеграцияRMQБезопасноеХранилищеДанных.СоздатьМенеджерЗаписи();
	БезопасноеХранилищеДанных.Владелец = Владелец;
	БезопасноеХранилищеДанных.Прочитать();
	Если ТипЗнч(БезопасноеХранилищеДанных.Данные) = Тип("ХранилищеЗначения") Тогда

		ДанныеДляСохранения = БезопасноеХранилищеДанных.Данные.Получить();
		Если Ключи <> Неопределено
		   И ТипЗнч(ДанныеДляСохранения) = Тип("Структура") Тогда

			СписокКлючей = ИнтеграцияRMQКлиентСервер.РазложитьСтрокуВМассивПодстрок(Ключи, ",", Ложь);
			Если БезопасноеХранилищеДанных.Выбран()
			   И СписокКлючей.Количество() > 0 Тогда

				Для каждого КлючДляУдаления Из СписокКлючей Цикл
					Если ДанныеДляСохранения.Свойство(КлючДляУдаления) Тогда
						ДанныеДляСохранения.Удалить(КлючДляУдаления);
					КонецЕсли;
				КонецЦикла;
				ДанныеДляХранилищеЗначения = Новый ХранилищеЗначения(ДанныеДляСохранения, Новый СжатиеДанных(6));
				БезопасноеХранилищеДанных.Данные = ДанныеДляХранилищеЗначения;
				БезопасноеХранилищеДанных.Записать();
				Возврат;

			КонецЕсли;

		КонецЕсли;

	КонецЕсли;

	БезопасноеХранилищеДанных.Удалить();

КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает таблицу обслуживаемых очередей
// 
// Возвращаемое значение:
//   ТаблицаЗначений   - таблица с колонками:
//     * ИмяСервиса - Строка - GUID очереди, в которой находится нужный обработчик события
//     * СтрокаБрокера - Строка - строка подключения к брокеру сообщений
//     * Таймаут - Число - Максимальное время в секундах, в которое сервис не будет посылать очередной wake-сигнал. 
//     * ПроцедураОбработчик - Строка - полный путь к процедуре обработчика сервиса обратного вызова (например: "МойМодуль.МояПроцедура")
//     * ИмяОчереди - Строка - имя очереди
//     * Durable - Булево -
//     * Exclusive - Булево - 
//     * Autodelete - Булево -
// 	
Функция ОбслуживаемыеОчереди() Экспорт

	ТипСтрока0 = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(0));
	ТипСтрока20 = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(20));
	ТипСтрока36 = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(36));
	ТипБулево = Новый ОписаниеТипов("Булево");
	ТипЧисло6П = Новый ОписаниеТипов("Число",, Новый КвалификаторыЧисла(6, 0, ДопустимыйЗнак.Неотрицательный));

	Очереди = Новый ТаблицаЗначений();

	Очереди.Колонки.Добавить("ИмяСервиса", ТипСтрока36);
	Очереди.Колонки.Добавить("Таймаут", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(8)));
	Очереди.Колонки.Добавить("ПроцедураОбработчик", ТипСтрока0);

	// Описание брокера
	Очереди.Колонки.Добавить("Брокер", Новый ОписаниеТипов("СправочникСсылка.ИнтеграцияRMQБрокеры"));
	Очереди.Колонки.Добавить("СерверБрокера", ТипСтрока0);
	Очереди.Колонки.Добавить("ПортБрокера", ТипЧисло6П);
	Очереди.Колонки.Добавить("ВиртуальныйХостБрокера", ТипСтрока20);
	Очереди.Колонки.Добавить("ЛогинБрокера", ТипСтрока20);

	// Описание точки обмена
	Очереди.Колонки.Добавить("ТочкаОбмена", Новый ОписаниеТипов("СправочникСсылка.ИнтеграцияRMQТочкиОбмена"));
	Очереди.Колонки.Добавить("ИмяТочкиОбмена", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(255)));
	Очереди.Колонки.Добавить("ТипТочкиОбмена", Новый ОписаниеТипов("ПеречислениеСсылка.ИнтеграцияRMQТипТочкиОбмена"));

	// Описание очереди
	Очереди.Колонки.Добавить("ИмяОчереди", ТипСтрока0);
	Очереди.Колонки.Добавить("Durable", ТипБулево);
	Очереди.Колонки.Добавить("Exclusive", ТипБулево);
	Очереди.Колонки.Добавить("Autodelete", ТипБулево);
	Очереди.Колонки.Добавить("DeadLetterExchange", ТипБулево);

	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ИнтеграцияRMQОчереди.Ссылка КАК Ссылка,
	|	ИнтеграцияRMQОчереди.Владелец.Владелец КАК Брокер,
	|	ИнтеграцияRMQОчереди.Владелец.Владелец.Сервер КАК СерверБрокера,
	|	ИнтеграцияRMQОчереди.Владелец.Владелец.Порт КАК ПортБрокера,
	|	ИнтеграцияRMQОчереди.Владелец.Владелец.ИмяВиртуальногоХоста КАК ВиртуальныйХостБрокера,
	|	ИнтеграцияRMQОчереди.Владелец.Владелец.Логин КАК ЛогинБрокера,
	|	ИнтеграцияRMQОчереди.Владелец КАК ТочкаОбмена,
	|	ИнтеграцияRMQОчереди.Владелец.Имя КАК ИмяТочкиОбмена,
	|	ИнтеграцияRMQОчереди.Владелец.Тип КАК ТипТочкиОбмена,
	|	ИнтеграцияRMQОчереди.Таймаут,
	|	ИнтеграцияRMQОчереди.ПроцедураОбработчик,
	|	ИнтеграцияRMQОчереди.ИмяОчереди,
	|	ИнтеграцияRMQОчереди.Durable,
	|	ИнтеграцияRMQОчереди.Exclusive,
	|	ИнтеграцияRMQОчереди.Autodelete,
	|	ИнтеграцияRMQОчереди.DeadLetterExchange
	|ИЗ
	|	Справочник.ИнтеграцияRMQОчереди КАК ИнтеграцияRMQОчереди
	|ГДЕ
	|	НЕ ИнтеграцияRMQОчереди.ПометкаУдаления";
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл

		Очередь = Очереди.Добавить();
		ЗаполнитьЗначенияСвойств(Очередь, Выборка);
		Очередь.ИмяСервиса = Строка(Выборка.Ссылка.УникальныйИдентификатор());

	КонецЦикла;

	Возврат Очереди;

КонецФункции

Процедура ОбработатьВызовСервиса(Очередь) Экспорт

	ПараметрыБрокера = Новый Структура;
	ПараметрыБрокера.Вставить("Брокер", Очередь.Брокер);
	ПараметрыБрокера.Вставить("Сервер", Очередь.СерверБрокера);
	ПараметрыБрокера.Вставить("Порт", Очередь.ПортБрокера);
	ПараметрыБрокера.Вставить("ИмяВиртуальногоХоста", Очередь.ВиртуальныйХостБрокера);
	ПараметрыБрокера.Вставить("Логин", Очередь.ЛогинБрокера);

	Сообщение = "";

	Попытка
		КлиентRMQ = НовыйКлиентRMQ(ПараметрыБрокера);	
	Исключение
		
		ШаблонСообщения = НСтр("ru = 'Не удалось прочитать или обработать сообщение из очереди %1.
							   |Отказ в подключении компоненты обмена с RabbitMQ:
							   |%2'", КодОсновногоЯзыка());
		
		ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонСообщения, 
			Очередь.ИмяОчереди, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));

		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);
		
	КонецПопытки;

	Если КлиентRMQ = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Попытка

		Потребитель = КлиентRMQ.BasicConsume(Очередь.ИмяОчереди, "", Истина, Ложь, 0);

		Пока КлиентRMQ.BasicConsumeMessage("", Сообщение, 5) Цикл

			//@skip-warning
			ПараметрыСообщения = Новый Структура;
			РезультатОбработки = СтатусПодтвердить();

			СтрокаВызова = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
				"%1(Сообщение, ПараметрыСообщения, РезультатОбработки)", 
				Очередь.ПроцедураОбработчик);
			Выполнить СтрокаВызова;

			Если РезультатОбработки = СтатусПодтвердить() Тогда
				КлиентRMQ.BasicAck();
			Иначе
				// Любое иное считаем поведением по умолчанию
			КонецЕсли;

		КонецЦикла;

		КлиентRMQ.BasicCancel(Потребитель);

	Исключение

		ШаблонТекста = НСтр("ru = 'Не удалось прочитать или обработать сообщение из очереди %1 по причине:
							|СВЕДЕНИЯ СИСТЕМЫ (если есть):
							|%2
							|СВЕДЕНИЯ КОМПОНЕНТЫ (если есть):
							|%3'", КодОсновногоЯзыка());
 
		ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонТекста,
			Очередь.ИмяОчереди, 
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
			КлиентRMQ.GetLastError());

		ЗаписьЖурналаРегистрации(
			ИмяСобытияЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.HTTPСервисы.Service1C2RMQ,
			,
			ТекстОшибки);

	КонецПопытки;

	КлиентRMQ = Неопределено;

КонецПроцедуры

// Преобразует строку таблицы значений в структуру.
// Свойства структуры и их значения совпадают с колонками переданной строки.
//
// Параметры:
//  СтрокаТаблицыЗначений - СтрокаТаблицыЗначений - строка таблицы значений.
//
// Возвращаемое значение:
//  Структура - преобразованная строка таблицы значений.
//
Функция СтрокаТаблицыЗначенийВСтруктуру(СтрокаТаблицыЗначений) Экспорт

	Структура = Новый Структура;
	Для каждого Колонка Из СтрокаТаблицыЗначений.Владелец().Колонки Цикл
		Структура.Вставить(Колонка.Имя, СтрокаТаблицыЗначений[Колонка.Имя]);
	КонецЦикла;

	Возврат Структура;

КонецФункции

Функция ИмяСобытияЖурналаРегистрации() Экспорт

	Возврат НСтр("ru = 'Интеграция 1С2RMQ'", КодОсновногоЯзыка());

КонецФункции

Функция КодОсновногоЯзыка() Экспорт

	Возврат Метаданные.ОсновнойЯзык.КодЯзыка;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ДанныеИзБезопасногоХранилища(Владелец, Ключ)

	Результат = Новый Структура(Ключ);

	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
		|	БезопасноеХранилищеДанных.Данные КАК Данные
		|ИЗ
		|	РегистрСведений.ИнтеграцияRMQБезопасноеХранилищеДанных КАК БезопасноеХранилищеДанных
		|ГДЕ
		|	БезопасноеХранилищеДанных.Владелец = &Владелец";

	Запрос.УстановитьПараметр("Владелец", Владелец);
	РезультатЗапроса = Запрос.Выполнить().Выбрать();

	Если РезультатЗапроса.Следующий() Тогда

		Если ЗначениеЗаполнено(РезультатЗапроса.Данные) Тогда
			СохраненныеДанные = РезультатЗапроса.Данные.Получить();
			Если ЗначениеЗаполнено(СохраненныеДанные) Тогда
				ЗаполнитьЗначенияСвойств(Результат, СохраненныеДанные);
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции

// Инициализирует компоненту и создает подключение к брокеру
// 
// Параметры:
// 	Брокер - СправочникСсылка.ИнтеграцияRMQБрокеры, Структура - Ссылка на элемент или готовые описания параметров брокера
// Возвращаемое значение:
// 	Компонента, Неопределено - В случае успеха создания возвращается компонента подключения к брокеру
//
Функция НовыйКлиентRMQ(Брокер)

	ПараметрыБрокера = Новый Структура;
	ПараметрыБрокера.Вставить("Сервер");
	ПараметрыБрокера.Вставить("Порт");
	ПараметрыБрокера.Вставить("ИмяВиртуальногоХоста");
	ПараметрыБрокера.Вставить("Логин");
	ПараметрыБрокера.Вставить("Пароль");

	ПодключитьКомпонентуRMQ();

	Если ТипЗнч(Брокер) = Тип("СправочникСсылка.ИнтеграцияRMQБрокеры") Тогда

		ЗаполнитьЗначенияСвойств(ПараметрыБрокера, Справочники.ИнтеграцияRMQБрокеры.ПараметрыБрокера(Брокер));
		УстановитьПривилегированныйРежим(Истина);
		ПарольБрокера = ИнтеграцияRMQ.ПрочитатьДанныеИзБезопасногоХранилища(Брокер);
		УстановитьПривилегированныйРежим(Ложь);
		ПараметрыБрокера.Пароль = ПарольБрокера;

	Иначе

		ПараметрыБрокера.Сервер = Брокер.Сервер;
		ПараметрыБрокера.Порт = Брокер.Порт;
		ПараметрыБрокера.ИмяВиртуальногоХоста = Брокер.ИмяВиртуальногоХоста;
		ПараметрыБрокера.Логин = Брокер.Логин;

		Если Брокер.Свойство("Пароль") Тогда
			ПарольБрокера = Брокер.Пароль;

		Иначе

			УстановитьПривилегированныйРежим(Истина);
			ПарольБрокера = ИнтеграцияRMQ.ПрочитатьДанныеИзБезопасногоХранилища(Брокер.Брокер);
			УстановитьПривилегированныйРежим(Ложь);

		КонецЕсли;
		ПараметрыБрокера.Пароль = ПарольБрокера;

	КонецЕсли;

	КлиентRMQ = Новый("AddIn.driver1C2RMQ.driver1C2RMQ");

	Попытка

		КлиентRMQ.Connect(
			ПараметрыБрокера.Сервер,
			ПараметрыБрокера.Порт,
			ПараметрыБрокера.Логин,
			ПараметрыБрокера.Пароль,
			ПараметрыБрокера.ИмяВиртуальногоХоста);

	Исключение

		ШаблонОшибки = НСтр("ru = 'При подключении к брокеру возникла ошибка:
			|СВЕДЕНИЯ СИСТЕМЫ (если есть):
			|%1
			|СВЕДЕНИЯ КОМПОНЕНТЫ (если есть):
			|%2'", КодОсновногоЯзыка());

		ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
			ШаблонОшибки,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			КлиентRMQ.GetLastError());

		ЗаписьЖурналаРегистрации(
			ИмяСобытияЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			ТекстОшибки);

		ВызватьИсключение ТекстОшибки;

	КонецПопытки;

	Возврат КлиентRMQ;

КонецФункции

Процедура ПодключитьКомпонентуRMQ()

	КомпонентаПодключена = Ложь;
	ТекстОшибки = "";
	
	СисИнфо = Новый СистемнаяИнформация();
	Если СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86_64
	 ИЛИ СисИнфо.ТипПлатформы = ТипПлатформы.Windows_x86 Тогда

		КомпонентаПодключена = ПодключитьВнешнююКомпоненту(
			"ОбщийМакет.driver1C2RMQ",
			"driver1C2RMQ",
			ТипВнешнейКомпоненты.Native);
			
		Если НЕ КомпонентаПодключена Тогда

			ШаблонОшибки = НСтр("ru = 'Не удалось подключить компоненту 1С2RMQ для платформы %1.
							   |Операция отменена.'", КодОсновногоЯзыка()); 
			ТекстОшибки = ИнтеграцияRMQКлиентСервер.ПодставитьПараметрыВСтроку(
				ШаблонОшибки,
				СисИнфо.ТипПлатформы);

			ЗаписьЖурналаРегистрации(
				ИмяСобытияЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.HTTPСервисы.Service1C2RMQ,
				,
				ТекстОшибки);

		КонецЕсли;

	Иначе

		ТекстОшибки = НСтр("ru = 'Работы компоненты 1С2RMQ поддерживается только для платформ:
						   |- Windows_x86_64
						   |- Windows_x86
						   |Операция отменена.'", КодОсновногоЯзыка());

		ЗаписьЖурналаРегистрации(
			ИмяСобытияЖурналаРегистрации(),
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.HTTPСервисы.Service1C2RMQ,
			,
			ТекстОшибки);

	КонецЕсли;
	
	Если НЕ КомпонентаПодключена Тогда
		ВызватьИсключение ТекстОшибки;		
	КонецЕсли;

КонецПроцедуры

Процедура ВыполнитьПроверкиПараметровОтправки(Сообщение, ТочкаОбмена, Параметры, Устойчивое)

	Если ТипЗнч(ТочкаОбмена) <> Тип("СправочникСсылка.ИнтеграцияRMQТочкиОбмена") Тогда
		
		ТекстОшибки = НСтр("ru = 'В методе ОтправитьСообщение переданный параметр ТочкаОбмена имеет недопустимый тип'", 
							КодОсновногоЯзыка()); 
		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ТипЗнч(Параметры) <> Тип("Строка")
	   И ТипЗнч(Параметры) <> Тип("Неопределено") Тогда
		
		ТекстОшибки = НСтр("ru = 'В методе ОтправитьСообщение переданный параметр Параметры имеет недопустимый тип'", 
							КодОсновногоЯзыка()); 
		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ТипЗнч(Устойчивое) <> Тип("Булево") Тогда
		
		ТекстОшибки = НСтр("ru = 'В методе ОтправитьСообщение переданный параметр Устойчивое имеет недопустимый тип'", 
							КодОсновногоЯзыка()); 
		ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрации(), УровеньЖурналаРегистрации.Ошибка,,, ТекстОшибки);

		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти